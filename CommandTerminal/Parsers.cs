
namespace SomeProject.CommandTerminal
{

    /// <summary>
    /// Encapsulates a method that does parsing.
    /// This is cleaner with concrete types instead of the generic System.Func's or
    /// even named delegates, plus these classes are mostly autogenerated. 
    /// </summary>
    public interface IValueParser<T>
    {
        ParseSummary Parse(string input, out T result);
    }

    /// <summary>
    /// Essentially, provides no-throw error handling for parsers.
    /// </summary>
    public readonly struct ParseSummary
    {
        public readonly string Message;
        public bool IsError => Message != null;
        public ParseSummary(string message) { Message = message; }
        public static readonly ParseSummary Success = new ParseSummary(null);
        public static ParseSummary TypeMismatch(string expectedTypeName, string actualInput) => new ParseSummary($"Expected input compatible with type {expectedTypeName}, got {actualInput}.");
    }

    
    public class BoolParser : IValueParser<bool>
    {
        public ParseSummary Parse(string input, out bool value) => Generated.Parsers.Parse(input, out value);
    }

    public class StringParser : IValueParser<string>
    {
        public ParseSummary Parse(string input, out string value) 
        {
            value = input;
            return ParseSummary.Success;   
        }
    }

    // This is integrated with the other generated types in a single Parsers static class,
    // which is why we have this namespace here.
    // TODO: I may figure out a cleaner solution.
    namespace Generated
    {
        public static partial class Parsers
        {
            public static readonly BoolParser Bool = new BoolParser();
            public static readonly StringParser String = new StringParser();

            public static ParseSummary Parse(this string input, out bool result)
            {
                if (string.Compare(input, "TRUE", ignoreCase: true) == 0) 
                {
                    result = true;
                    return ParseSummary.Success;
                }

                if (string.Compare(input, "FALSE", ignoreCase: true) == 0) 
                {
                    result = false;
                    return ParseSummary.Success;
                }

                result = default;
                return ParseSummary.TypeMismatch("bool", input);
            }
        }
    }
}